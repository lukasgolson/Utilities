import hashlib
import os
import logging
from pathlib import Path

logger = logging.getLogger(__name__)


class ProjectVersion:

    words_list = [
        "Alfa", "Bravo", "Charlie", "Delta", "Echo", "Foxtrot", "Golf", "Hotel",
        "India", "Juliett", "Kilo", "Lima", "Mike", "November", "Oscar", "Papa",
        "Quebec", "Romeo", "Sierra", "Tango", "Uniform", "Victor", "Whiskey",
        "X-ray", "Yankee", "Zulu", "Apple", "Banana", "Cherry", "Date", "Elder",
        "Fig", "Grape", "Honey", "Kiwi", "Lemon", "Mango", "Nectarine", "Olive",
        "Peach", "Quince", "Raspberry", "Strawberry", "Tangerine", "Valencia",
        "Watermelon", "Xigua", "Yam", "Zucchini", "Ant", "Bear", "Cat", "Dog",
        "Eagle", "Fox", "Giraffe", "Hippo", "Iguana", "Jaguar", "Kangaroo", "Lion",
        "Monkey", "Newt", "Owl", "Penguin", "Quail", "Rabbit", "Shark", "Turtle",
        "Urchin", "Vulture", "Walrus", "Yak", "Zebra", "Apricot", "Blueberry",
        "Cantaloupe", "Dragonfruit", "Elderberry", "Guava", "Honeydew", "Jackfruit",
        "Kumquat", "Lime", "Mulberry", "Nutmeg", "Passion", "Radish", "Squash",
        "Orange", "Ugli", "Vanilla", "Watercress", "Yarrow", "Amaranth", "Basil",
        "Chive", "Dill", "Endive", "Fennel", "Garlic", "Horseradish", "Iceberg",
        "Jicama", "Kale", "Lettuce", "Mint", "Nori", "Oregano", "Parsley", "Quinoa",
        "Radicchio", "Sage", "Thyme", "Upland", "Vetch", "Wasabi", "Almond",
        "Cashew", "Chestnut", "Hazelnut", "Macadamia", "Peanut", "Pecan", "Pistachio",
        "Walnut", "Amethyst", "Aquamarine", "Diamond", "Emerald", "Fire Opal",
        "Garnet", "Jade", "Onyx", "Pearl", "Quartz", "Ruby", "Sapphire", "Topaz",
        "Turquoise", "Zircon", "Abacus", "Bell", "Candle", "Drum", "Egg", "Flute",
        "Guitar", "Harmonica", "Icicle", "Jar", "Kite", "Lantern", "Mirror",
        "Notebook", "Oboe", "Paintbrush", "Quilt", "Ruler", "Scissors", "Tambourine",
        "Ukulele", "Vase", "Whistle", "Xylophone", "Yarn", "Zipper", "Acorn",
        "Bookmark", "Compass", "Dice", "Envelope", "Feather", "Globe", "Hammer",
        "Ink", "Journal", "Key", "Lock", "Magnet", "Nail", "Ornament", "Paperclip",
        "Quill", "Ruler", "Stapler", "Ticket", "Umbrella", "Violin", "Wheel",
        "Yo-yo", "Asphalt", "Brick", "Cement", "Dirt", "Earth", "Foam", "Granite",
        "Herb", "Iron", "Jade", "Kelp", "Limestone", "Marble", "Nectar", "Opal",
        "Plaster", "Quartz", "Rock", "Sand", "Tile", "Underlay", "Vine", "Wool",
        "Yardstick", "Zenith", "Arch", "Beam", "Column", "Dome", "Edge", "Floor",
        "Gable", "Height", "Isle", "Joy", "Keystone", "Ledge", "Mantle", "Nook",
        "Oriel", "Parapet", "Quoin", "Rafter", "Stair", "Truss", "Upper", "Vault",
        "Wall", "Zone", "Act", "Ban", "Cast", "Drift", "Echo"
    ]

    def __init__(self, directory_path: Path):
        """
        Initialize the VersionHasher with the path to the directory.

        Args:
            directory_path (str): Path to the directory containing Python files.
        """
        self.directory_path = directory_path

    def hash(self, length: int = -1, phonetic : bool = False) -> str:
        """
        Calculate a unique version hash for all Python files in the directory
        and its subdirectories based on their contents.

        Returns:
            str: A unique hash string composed of phonetic words.
        """
        hasher = hashlib.md5(usedforsecurity=False)  # Create a new SHA-256 hash object

        try:
            for root, _, files in os.walk(self.directory_path):
                for file in files:
                    if file.endswith('.py'):  # Check for Python files
                        file_path = os.path.join(root, file)
                        with open(file_path, 'rb') as f:
                            # Update the hash with the content of the file
                            while chunk := f.read(8192):  # Read in chunks
                                hasher.update(chunk)

            version_hash = hasher.hexdigest()

            if length is not None and length > 0:
                version_hash = version_hash[:length * 2]

            if phonetic:
                # Map each pair of hex characters to a word
                words = []
                for i in range(0, len(version_hash), 2):
                    hex_pair = version_hash[i:i + 2]
                    index = int(hex_pair, 16)

                    index = index % len(self.words_list)  # Wrap around if index is out of range
                    word = self.words_list[index]
                    words.append(word)

                return ' '.join(words)
            else:
                return version_hash

        except Exception as e:
            logger.error(f"Failed to calculate version hash: {e}")
            return "unknown"
